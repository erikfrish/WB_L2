package main

/*
Visitor

Этот паттерн позволяет встроить дополнительный функционал в объект какого-то типа не изменяя методы этого типа,
разве что добавляя простейший метод Accept для принятия самого визитера,
который всего лишь вызывает необходимый метод у самого визитера, например:
func (o *Object) Accept(v Visitor) {
	v.visitForObject(o)
}
Таким образом мы создаем отдельный тип визитера, который будет отвечать за новый функционал,
например CalculateArea для расчета площади каждой фигуры, саму логику расчета описываем в методе
visitForObject для нового типа визитера. Можно создать другого визитера для другого функционала,
главное реализовать логику в том же методе, чтобы Object вызывал его также, как и с другими визитерами.
В зависимости от того, какого визитера мы передадим объекту может быть проделано то или иное действие.

Это может быть полезно в случае, когда изменение или добавление сложных методов исходного типа нежелательно,
метод Accept настолько прост, что отлавливать в нем баги не будет необходимости,
а если баги будут в реализации визитера, это не затронет ни коим образом весь ранее написанный код,
новый функционал обособлен от старой реализации и не ограничен почти ничем.
*/

import (
	"03_visitor/pattern"
	"fmt"
)

func main() {
	sq := pattern.MakeSquare(10.0)
	re := pattern.MakeRectangle(3.0, 5.0)
	ci := pattern.MakeCircle(4.0)
	var vi pattern.Visitor = &pattern.CalculateArea{}
	sq.Accept(vi)
	fmt.Printf("\nArea of sq = %f\n", vi.(*pattern.CalculateArea).Area)
	re.Accept(vi)
	fmt.Printf("\nArea of re = %f\n", vi.(*pattern.CalculateArea).Area)
	ci.Accept(vi)
	fmt.Printf("\nArea of ci = %f\n", vi.(*pattern.CalculateArea).Area)
}
